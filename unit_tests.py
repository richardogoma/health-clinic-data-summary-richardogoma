# -*- coding: utf-8 -*-
"""unit_tests.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GrXQarvRoFvKmDtWkmUb_8NhkmeA3Rln
"""

import csv

def load_data(filepath: str) -> list[dict]:
    """
    Loads patient vital signs data from a CSV file.

    Args:
        filepath (str): The path to the CSV file.

    Returns:
        list[dict]: A list of dictionaries, where each dictionary represents one patient.
                    Returns an empty list if an error occurs.
    """
    patient_data = []
    try:
        with open(filepath, mode='r', newline='', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            for row in reader:
                processed_row = {}
                for key, value in row.items():
                    try:
                        if key in ['patient_id', 'age', 'heart_rate', 'systolic_bp', 'oxygen_saturation']:
                            processed_row[key] = int(value)
                        elif key in ['temperature']:
                            processed_row[key] = float(value)
                    except ValueError:
                        print(f"Warning: Could not convert '{value}' for column '{key}' to a numeric type in row: {row}")
                        processed_row[key] = None
                patient_data.append(processed_row)
        print(f"Successfully loaded data from {filepath}.")
    except FileNotFoundError:
        print(f"Error: The file '{filepath}' was not found.")

    return patient_data

raw_data = load_data('/data/patient_vitals.csv')
raw_data[:5]

def calculate_mean(values: list[float | int]) -> float | None:
    """
    Calculates the arithmetic mean of a list of numeric values.

    Args:
        values (list[float | int]): A list of numbers.

    Returns:
        float | None: The arithmetic mean of the values, or None if the list is empty.
    """
    numeric_values = [v for v in values if v is not None]
    if not numeric_values:
        return None
    return sum(numeric_values) / len(numeric_values)

calculate_mean([1, 2, 3, 100])

def calculate_median(values: list[float | int]) -> float | None:
    """
    Calculates the median of a list of numeric values.

    Args:
        values (list[float | int]): A list of numbers.

    Returns:
        float | None: The median of the values, or None if the list is empty.
    """
    numeric_values = sorted([v for v in values if v is not None])
    n = len(numeric_values)

    if n == 0:
        return None
    elif n % 2 == 1:
        return float(numeric_values[n // 2])
    else:
        mid1 = numeric_values[n // 2 - 1]
        mid2 = numeric_values[n // 2]
        return (float(mid1) + float(mid2)) / 2

calculate_median([1, 2, 3, 100])

from collections import Counter

def calculate_mode(values: list[float | int]) -> list[float | int] | None:
    """
    Calculates the mode(s) of a list of numeric values.

    Args:
        values (list[float | int]): A list of numbers.

    Returns:
        list[float | int] | None: A list of the most frequent value(s), or None if the list is empty.
    """
    numeric_values = [v for v in values if v is not None]

    if not numeric_values:
        return None

    counts = Counter(numeric_values)

    max_frequency = 0
    if counts:
        max_frequency = max(counts.values())

    modes = [key for key, value in counts.items() if value == max_frequency]

    return sorted(modes)

calculate_mode([1, 2, 3, 2])

def calculate_outliers(values: list[float | int]) -> list[float | int]:
    """
    Calculates outliers using the Interquartile Range (IQR) method.

    Args:
        values (list[float | int]): A list of numeric values.

    Returns:
        list[float | int]: A list of values identified as outliers.
    """
    numeric_values = sorted([v for v in values if v is not None])
    n = len(numeric_values)

    if n < 2: # At least two values are needed to define a range, though more for robust quartiles
        return []

    # Calculate Q1 (median of the first half of the data)
    q1_data = numeric_values[0 : n // 2]
    q1 = calculate_median(q1_data)

    # Calculate Q3 (median of the second half of the data)
    # If n is odd, the overall median element is typically excluded from both halves
    # for Q1 and Q3 calculation using this method.
    q3_start_index = (n // 2) + (n % 2)
    q3_data = numeric_values[q3_start_index : n]
    q3 = calculate_median(q3_data)

    # If Q1 or Q3 could not be calculated (e.g., too few elements in halves),
    # return an empty list of outliers.
    if q1 is None or q3 is None:
        return []

    iqr = q3 - q1
    lower_bound = q1 - (1.5 * iqr)
    upper_bound = q3 + (1.5 * iqr)

    outliers = []
    for value in numeric_values:
        if value < lower_bound or value > upper_bound:
            outliers.append(value)

    return outliers

calculate_outliers([1, 2, 3, 4, 5, 7, 10, 100])